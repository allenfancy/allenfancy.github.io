---
layout: post
title: "服务器容错"
date: 2017-07-04
description: "服务器容错"
tag: 分布式
---   

### 一、遇到的重大事故
        1.系统依赖的某个发生延迟或故障，数秒内导致所有应用资源(线程、队列等)被耗尽，造成所谓的雪崩效应(Cascading Failure),导致整个系统拒绝对外提供服务
        2.系统遭受恶意爬虫袭击，在放大效应下没有对下游依赖服务做好限速处理，最终导致下游服务奔溃。
    
### 二、设计原则：
        服务容错的设计原则：就是为失败而设计。为了避免一个小问题，影响全局的情况，在这种情况情况下，在设计原则上有以下目标：
        1.一个依赖服务的故障不会严重破坏用户体验。
        2.系统能自动或半自动处理故障，具备自我恢复能力
    基于这个原则和目标，出现下面要介绍的一些模式，能够解决分布式服务调用中的一些问题，提高系统在故障发生时的存活能力

### 三、经典的容错模式：
    所谓模式，其实就是某种场景下一类问题及其解决方案的总结归纳，往往可以重用。模式可以指导我们完成任务，作出合理的系统设计方案，达到事半功倍的效果。而在服务容错这个方案，业务内已经有了不少实践总结出的解决方案：
    
    1、超时和重试(Timeout and Retry)
       超时模式：是一种最常见的容错模式。常常的有设置网络连接超时时间，一次RPC的响应超时时间等。在分布式服务调用场景中，它主要解决了当依赖服务出现建立网络连接或响应延迟，不用无限等待的问题，调用方可以根据事先设计的超时时间中断调用，及时释放关键资源，如Web容器的链接，数据库连接数等，避免整个系统资源耗尽出现拒绝对外提供服务这种情况。
       重试模式：一般和超时模式一起使用，适用于对下游服务的数据依赖的场景，通过重试来保证数据的可靠性或一致性，通常用于因网络抖动等导致服务调用出现超时的场景。与超时时间设置结合使用后，需要考虑接口的响应时间分布情况，超时时间可以设置为服务依赖接口99.5%响应时间的值，重试次数一般为1-2次最好，否则会导致请求响应延长，拖累到整个系统。
   
    2、限流(Rate limiting/load Shedder)
        限流模式，常用于下游服务器容量有限，但又怕出现突发流量猛增而导致下游服务因压力过大而拒绝服务的场景。常见的限流模式有：控制并发和控制速率，一个是限制并发数量，一个限制访问的速率。
        控制并发：属于一种常见的手段，在工程实践中可以通过信号量限制来控制，例如：有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以在启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，那么我们就必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库的链接。
        控制速率：常见是使用令牌桶算法来实现这种模式.Guava中的RateLimiter来实现控制速率
        
    3.电路熔断器(Circuit Breaker):
        熔断器模式可以防止我们的系统不断地尝试执行可能会失败的调用，使得我们的系统继续执行而不用等待修正错误，或者浪费CPU时间去等待长时间的超时产生。熔断器模式可以使我们系统能够检测错误是否已经修正，如果已经修正，系统会再次连接。内部的状态
        1.闭合状态：该状态下能够对目标服务或方法进行正常调用。熔断器类维护了一个时间窗口内调用失败的次数，如果某次调用失败，则失败次数加1。        
        2.断开(Open)状态：在该状态下，对目标服务或方法的请求会立即返回错误响应，如果设置了fallback方法，则会进入fallback的流程。    
        3.半断开状态
    熔断器模式往往用于服务的自动降级，在实现主要基于Netflix开源的组件Hystrix来实现。
    
    4.舱壁模式(BulkHead Isolation):
        线程隔离(Thread Isolation)就是这种模式的一种场景。例如：系统A调用ServiceB、ServiceC、ServiceD三个远程服务，且A服务部署了120个线程。那么分别给三个服务分配40个线程。
        实践中：如某个接口访问数据库查询慢，外部RPC调用超时导致整个系统的线程数过高，连接数耗尽等。都可以使用仓壁模式。
    
    5.回退模式：
        在超时、重试失败，熔断或者限流发生的时候，为了及时恢复服务或者不影响到用户体验，需要提供回退的机制，常见的回退策略：
        自定义处理：
        故障沉默：
        快速失败：直接抛出异常
    