---
layout: post
title: "Mysql锁机制和查询优化"
date: 2018-01-23
description: "Mysql锁机制"
tag: MySQL
---

### 1、概述
    总体MySql存储引擎使用了三种级别的锁机制:行级锁、页级锁和表级锁
    1、行级锁(row-level)
        优点：锁定对象的粒度很小，因此锁定的资源争用过的概率也很低，能给应用程序最大的并发处理能力.
        缺点：因为每次锁定的资源粒度很小，因此每次获取锁和释放锁需要做的事儿就更多，带来消耗也很大的。此外，行级锁很容易发生死锁
    2、表级别锁(table-level)
        优点：实现简单，系统负面影响小，获取锁和释放锁的速度很快。避免死锁问题
        缺点：并发能力不足
    3、页级锁(page-level)
        介于 行级锁 <= 页级锁 <= 表级锁；
### 2、锁分析

#### 2.1 表级锁
    MYSQL的表锁定主要分为俩中类型，一种是读锁定、另一种是写锁定。在MySql中通过四个队列来维护这俩中锁：
    俩个存放当前锁定中的读和写锁定信息
    俩个用来存放等待中的读写锁定信息
    MySql内部11种锁定类型
    锁定类型                                    说明
    IGNORE                          当发生锁请求的时候内部交互使用，在锁定结构和队列中并不会有任何信息存储
    UNLOCK                          释放锁定请求的交互类型
    READ                            普通读锁定
    WRITE                           普通的写锁定
    READ_WITH_SHARED_LOCKS          在Innodb使用到，由如下方式产生：SELECT ... LOCK IN SHARE MODE
    READ_HIGH_PRIORITY              高优先级读锁定
    READ_NO_INSERT                  不允许Concurrent Insert的锁定
    WRITE_ALLOW_WRITE               
    WRITE_ALLOW_READ                这种锁定发生对表做DDL (ALTER TABLE ...)的时候，MySQL可以允许其他线程获取读锁定。
    WRITE_CONCURRENT_INSERT         正在进行Concurent Insert时候所使用的锁定方式，该锁定进行的时候，除了READ_NO_INSERT之外的其他任何读锁定都不会被阻塞
    WRITE_DELAYED                   使用 INSERT DELAYED时的锁定类型
    WRITE_LOW_PRIORITY
    WRITE_ONLY
    ------------------------------------------------------------------------------------------------------------------------
    读锁定：
        一个新的客户端请求在申请获取读锁资源的时候，需要满足以下条件:
            1、请求锁定的资源当前没有被写锁定
            2、写锁定等待队列中没有更高优先级的写锁定等待
        如果满足以上俩个条件，该请求会被立即通过，并将信息存入到Current read-lock queue中。如果不满足，会存入Pending read-lock queue中
    写锁定：
        当客户端请求写锁定的时候，MySQL首先检查在Current write-lock queue是否已经有锁定相同资源的信息存在。
        如果Current write-lock queue没有，则再检查Pending write-lock queue,如果在Pending write-lock queue中找到了,自己也需要进入等待队列中并暂停自身线程等待锁定资源。
        反之，如果Pending write-lock queue为空，则检查Current read-lock queue，如果有锁定存在，则同样需要进入Pending write-lock queue等待。

#### 2.2 行级锁
    行级锁是存储引擎自己实现的，如innodb存储引擎，以及MySQL分布式存储引擎NDB Cluster等
    Innodb的行级锁分为共享锁和排它锁，而在锁定机制的实现过程中未了让行级锁和表级锁共存，Innodb也同样使用了意向锁(表级锁)的概念，也分为意向共享锁和意向排他锁.package _posts
    说明才能获取：
        当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以加一个共享锁，不过不能加排他锁。
        但是如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加锁。
        意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁锁用的时候，该事务可以需要锁定行的表上添加一个合适的意向锁。如果自己需要一个共享锁，
        那么久在表上添加一个意向排它锁。意向锁可以同时并存多个，但是意向锁排他锁只能存在一个。
        因此In弄DB的锁定模式实际上可以分为四种:共享锁(S)、排他锁(X)、意向共享锁(IS)和意向排他锁(IX).具体的逻辑关系如下:
                            共享锁(S)      排他锁(X)     意向共享锁(IS)             意向排他锁(XS)
        共享锁(S)             兼容           冲突           兼容                      冲突
        排它锁(X)             冲突           冲突           冲突                      冲突
        意向共享锁(IS)         兼容          冲突            兼容                      兼容
        意向排他锁(XS)         冲突          冲突            兼容                      兼容
    Innodb的锁定规则是通过在指向数据记录的第一个索引键之前和最后一个索引键之后的空域空间上标记信息而实现的。InnoDB的这种锁定实现方式被称为
    "NEXT-KEY locking"(间隙锁)，因为Query执行过程中通过范围查找的，他会锁定整个范围所有的索引键值，即使这个键值并不存在.

    间隙锁有一个弱点：即当锁定一个范围键值之后，即使某些不存在的键值也会被锁定，而造成在锁定键值范围内的任何数据。在某些场景下可能对性能造成很大的危害。
    而InnoDB给出的解释是为了阻止幻读的情况出现。因此采用间隙锁。别的隐患:
        1. 当查询无法利用索引的嘶吼，InnoDB会放弃使用行级别锁而改用表级别的锁定，造成并发性能的降低。
        2. 当查询使用的索引不包含所有过滤条件的时候，数据检索使用的索引键所只想的数据可能有部分并不属于该查询的结果集的行列，但是也会被锁定，因为间隙锁是一个范围，而不是具体的索引键
        3. 当查询在使用索引定位数据的时候，如果使用的索引建一样但访问的数据行不同的时候，一样被锁定

### 3. MySQL 查询优化
#### 3.1 MySQL Query Optimizer工作原理
    MySQL Query Tree 是通过优化DBXP的经典数据结构和Tree构造器而产生的一个指导完成一个Query语句的请求所需要处理的工作步骤，可以简单认为就是一个数据出炉流程规划，用Tree数据结构存放而已
    处理流程：
        当客户端向MySQL请求一条Query，到命令及诶西去模块完成请求分类区别是SELECT并转发给Query Optimizer只有，Query Optimizer 首先会对整条Query进行，优化处理掉一些常量表达式预算，直接换成常量值。
        并对Query中的查询条件进行简化和转换，如去掉一些无用或者明显的条件，结构调整等等。然后在是分析Query中的Hint信息，看显示Hint信息是否可以完全确定改Query的执行计划。如果没有Hint或者Hint信息还不足以完全确定执行计划，则会读取锁涉及对象的统计信息，根据Query
        进行写相应的计算分析，然后再得出最后的执行计划。
#### 3.2 Query语句优化基本思路和原则
        1. 优化更需要优化的Query
        2. 定位优化对象的性能瓶颈
        3. 明确的优化目标
        4. 从Explain入手
        5. 使用profile
        6. 小结果集驱动大结果集
        7. 尽可能在索引中完成排序
        8. 只取需要的Columns
        9. 仅仅使用最有效的过滤条件
        10. 尽可能避免使用Join和子查询
    优化SQL的前提条件，首先需要判断是Query的瓶颈是IO还是CPU。到底因为在数据访问消耗了太多时间，还是在运算(如分组和排序)    
    Explain：
   |---------------------------------------------------------------------------------------------------------------------------------|
   | id select_type   table     paritions type  possible_keys     key     key_len     ref     rows    filtered    extra              |
   |---------------------------------------------------------------------------------------------------------------------------------|
   | 1	PRIMARY	    Employee	NULL	  ALL	NULL	        NULL	 NULL	     NULL	  6	      33.33	     Using where         |
   |---------------------------------------------------------------------------------------------------------------------------------|
   | 2	SUBQUERY	Employee	NULL	  ALL	NULL	        NULL	 NULL	     NULL	  6	      100.00	 NULL                |
   |---------------------------------------------------------------------------------------------------------------------------------|
    id：
        数字越大越先执行，如果ID相同，由上往下执行
    select_type:
        SIMPLE: 查询中给不包含子查询或者UNION查询
        PRIMARY: 查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY
        UNION: UNION 中的第二个或后面的SELECT语句
        DEPENDENT UNION：UNION中的第二个或者后面的SELECT语句，取决于外面部分
        UNION RESULT ： UNION的结果
        SUBQUERY：子查询中的第一个SELECT
        DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询
        DEVRIVED：派生表的SELECT，FROM子句的子查询
        UNCACHEABLE SUBQURERY 一个子查询的结果不能被缓存，必须重新评估外接的第一行
    partition(分区):
        1. 水平分区(根据行属性按照行分)
            1.1 Range(范围)： 
            1.2 Hash(哈希)：DBA通过对表一个或多个列的Hash KEY进行计算
            1.3 Key(键值)：
            1.4 List(预定义列表)
            1.5 Composite(符合模式)
        2. 垂直分区（按列分)

    type：
        1. ALL：FULL TABLE SCAN，遍历全表以找到匹配的行
        2. index：FULL INDEX SCAN，index与ALL区别为index类型只遍历索引树
        3. range: 只检索给定范围的行，使用一个索引来选择行
        4. index_subquery: （子查询未使用唯一索引，但是使用了索引）该连接类型类似于unique_subquery.可以替换IN子查询，但只适合下来形式的子查询中非唯一索引.
        5. unique_subquery: (子查询条件使用了唯一索引)该类型替换了下面形式的IN子查询的ref：value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。
        6. index_merge: 该连接类型表示使用了索引合并优化方法.（ select * from xxx where id=2 or uid = 1 ）
        7. ref_or_null: 该连接类型如同ref,但是添加了Mysql可以专门搜索包含NULL值的行
        8. ref: 表示表的连接匹配条件，即那些列或者常量被用于查找索引列上的值
        9. eq_ref: 区别在于使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key 或者 unique key作为关联条件
        10. const、system: 当Mysql对查询某部分进行优化，并转化为一个常量时，使用这些类型访问。比如说：主键位于where条件列表中，Mysql就能将查询转为一个常量，System是const的一个特例，当查询表只有一行数据时，就是system.
        NULL: MYSQL在优化查询分解语句，执行时甚至不用访问表或索引，例如从一个索引列表中选择最小值就可以通过单独索引查询完成。
    possible_keys:
        指出mysql能使用那些索引在表中查找记录，查询涉及的字段上若干索引，就会被列出，但不一定使用.
    key:
        key显示的是MYSQL实际使用的索引
    key_len:
        表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。显示的索引中最大可能使用的长度，并非实际的长度。
    ref:
        表示上述的连接匹配条件，即哪些列或者常量被用于查找索引列上的值
    rows:
        表示MYSQL根据表统计信息及索引选用的情况，估算的找到所需要的记录读取的行数
    filtered:
        显示了通过条件过滤出的行数的百分比估计值。
    Extra：
        该列包含Mysql解决查询详细的信息，有如下的情况：
            1. Distinct ：mysql发现第1个匹配后，停止为当前的行组合搜索更多的行
            2. Not exist： Mysql能对查询进行LEFT JOIN 优化，发现1个匹配LEFT JOIN标准后，不在为当前的行组合在该表内检查更多的行
            3. range checked for each record(index map:#): mysql没有发现好的可以使用的索引，但发现如果前面的表的列值已知，可能部分索引使用
            4. Using fileSort: Mysql中无法利用索引来完成的排序操作 (文件排序)。
            5. Using index： 从只使用索引树中的信而不需要进一步搜索读取实际的行来检索表中的列信息.
            7. Using temporary: 表示MySQL需要使用临时表来存储结果集，场景用于排序和分组查询
            8. Using where :列数据是仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部请求列都是同一个索引的部分时候，表示Mysql服务器将在存储引起检索后再进行过滤
            9. Using sort_union(...), Using union(...), Using intersect(...):这些函数说明如何为index_merge联接类型合并索引扫描。
            10. Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。
            11. Using join buffer: 该值强调了在获取连接条件时没有使用索引，并且需要连接缓存区来存储中间结果。如果出现这个值，那就需要注意，根绝查询的具体情况可能需要添加索引来改进
            12. Impossible where :这个值强调了where语句会导致没有符合条件的行
            13. Select tables optimized away: 这个值以为进通过使用索引，优化器可能仅从聚合函数中返回一行
        出现 2、4、7 的时候，需要改进SQL.
    
#### 3.3 索引

##### 3.3.1 索引
    索引是存储引擎用于快速查找到记录的一种数据结果，索引类似一本书的目录，可以根据目录快查找的数据。
##### 3.3.2 索引的类型
    索引是在MySQL的存储引擎层中实现的，而不是在服务层实现的。所以每种存储引擎的索引都是不一样的，也不是所有的存储引擎都支持所有的索引类型

###### 3.3.2.1 B+Tree 索引
    B+Tree索引是MyISAM和InnoDB的默认的索引类型，也可以在创建索引的时通过USING BTREE来显示执行。B-Tree是一种多叉平衡树、
    场景：
        1. 等值匹配
            = != <> IN  (NOT IN) <=> 查询语句的优化
        2. 范围匹配 
            > >= < <= BTEWEEN AND 等范围查询语句的优化
        3. 匹配最左前缀
            name like bai%这种模糊匹配的查询，是可以利用name字段上建立的索引，来欧化查询的
        4. 覆盖索引
            B-Tree索引的key存放的子弹的值，如果KEY中包含所有需要查询字段的值，就称为覆盖索引，覆盖索引能提高性能
        5. 排序
            B-Tree 索引是排好序的，所以MySQL可以用来优化ORDER BY 和 GROUP BY等操作
###### 3.3.2.2 Hash索引
    效率高，但是限制多。如：
        1. 只有精确匹配索引列的查询才有效，因为hash索引是利用索引的所有列的字段值来计算hash值的
        2. 只支持等值比较查询，不能支持范围查询
        3. 哈希索引的只包含索引字段的哈希值和指向数据的指针，所以不能使用索引中的值来避免读行
        4. hash索引的数据是无序的，无法用于排序
###### 3.3.2.2 全文索引
    全文索引是一种通过建立倒排索引，快速匹配文档的方式
##### 3.3.3 聚簇索引和非聚簇索引
###### 3.3.3.1 聚簇索引(innodb的索引类型实际上就是聚簇索引)
    聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，Innodb的索引实际上是将主键(primary eky)与数据行存放在同一个文件的，一张表只能有一个聚簇索引.
    InnoDB要求表必须有主键（MyISAM可以没有）,如果没有显式指定,则MySQL系统会用一个唯一且不为空的索引列做为主键,如果不存在这种列,则MySQL自动为InnoDB表生成一个隐含字段作为主键。
    InnoDB的普通索引(二级索引)的叶子节点中存放的是PRIMARY KEY的值，所以需要先查询普通索引的叶子界定啊找到对应的主键值，然后再根据主键值去聚簇索引中查找对应的数据.
        1. InnoDB将主键与数据聚集在一起的方式，让主键顺序的插入和查询效率非常的高，但是更新主键的字段或者不按照主键的顺序插入数据的代码会比较高，所以主键的选取非常重要(使用AUTO INCREMENT字段或者
        应用程序生成的顺序递增字段要比无序的UUID好）
        2. 二级索引会保存主键的值，所以主键的值不要太大
###### 3.3.3.3 非聚簇索引(MyISAM引擎使用的是非聚簇索引)
    MyISAM引擎的一张表中，会有三种文件：FRM(表结构)、MYD(数据，即数据库中的每个行)、MYI(索引)
    
    MYSQL使用索引查询数据时，先到MYI文件中找到数据存储的位置指针，然后再到MYD文件中读取数据
##### 3.3.4 高效的索引
    索引的代价：消耗存储空间，同时索引会加重插入、删除和修改记录的负担(每次这种操作都会让B+Tree中的数据结构发生变化，比如，分裂，旋转等)
    1. 独立的列
        索引不能用于计算，，如：select * from table where id + 1 = 5; //不会使用索引
    2. 索引的选择性
        索引的选择性是指不重复的索引值(Cardinality)和数据表的记录总数的比值(0,1],索引的选择性越高(接近1),查询时能够过滤掉的更多的行，效率也更高.
        越散列的值也高，过滤的数量越多
    3. 前缀索引
        对于字符列，可以使用列的前缀代替整个列作为索引key，当前缀长度适合时，可以做到即使前缀索引的选择接近全列索引，同时大大节约索引空间。
        对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引.
    4. 联合索引
        MySQL 允许对表上的多个列进行索引，联合索引的创建方法与单个索引创建的方法不一样，不同之处仅在于有多个索引列.