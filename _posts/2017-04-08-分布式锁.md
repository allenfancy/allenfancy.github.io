---
layout: post
title: "分布式锁"
date: 2017-04-08
description: "分布式锁"
tag: 分布式
---   


### 1.基于数据库资源表做乐观锁，用于分布式锁
     1.1 首先说明乐观锁的含义：
          大多数是局域数据版本(version)的记录机制实现的。什么是数据库版本号？即：为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库版本添加一个”version”字段来实现读取数据时，将此版本号一同读取出来，之后再做更新操作时，对此版本号加+1.在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败。
     1.2 具体实例：
          假设有一张表：t_resource,其中有id,resource,state,add_time,update_time,version.
          假设对id=xxx这条数据进行分配，那么在分布式的场景下，我们一般先查询出来state=1的数据，然后从其中选取一条数据可以通过update t_resource set state=1 where state = 1 and id = xxx.
          在分布式场景中，由于数据库的update操作是原子操作的。ABA问题？如果你第一次select 和第二次update过程中，由于俩次操作是非原子性的，所以这个过程中，如果有一个县城先占用了资源(state=2)，然后释放了资源(state = 1),实际上最后你执行update操作时，无法知道这个资源发生了变化。
          如何使用乐观锁解决上面的问题呢？
          1.先执行select操作查询出来当前数据的数据版本号，比如当前的version=26：
          select id,resource,state from t_resource where state = 1 and id = xxx
          2.执行更新操作
          update t_resource set  state = 2,version=27 where resource = xxx and state = 1 and version = 26
          3.如果上述的update语句真正更新影响到了一行数据，那就说明站位成功。如果没有影到一行数据，则说明这个资源已经被其他资源占位了。
     1.3 基于数据表做乐观锁的一些缺点：
          1.这种操作方式，使原来一次update操作，必须变为2次操作：select版本号一次，update一次。增加了数据库操作的次数。
          2.如果在业务场景中的一次业务流程中，多个资源都需要用保证数据一致性，那么如果全部使用基于数据库资源表的乐观锁，就要让每个资源都有一张资源表，这个在实际使用场景中肯定无法满足的。而且这些操作都是基于数据的操作，在高并发的情况下，对数据的链接的开销是无法接受的。
          3.乐观锁机制往往基于系统中的数据存储逻辑，因此可能会造成脏数据被更新到数据库中。