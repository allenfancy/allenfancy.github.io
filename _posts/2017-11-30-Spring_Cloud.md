---
layout: post
title: "Spring-Cloud-基础"
date: 2017-11-11
description: "Spring-Cloud-基础"
tag: Spring Cloud
---   

### 一、断路器
        在微服务架构中，将系统拆分成一个个的服务单元，各个单元通过服务注册和订阅的方式互相依赖。
        由于每个单元都在不同的进程中允许，依赖通过远程调用的方式执行，这样有可能因为网络原因或是依赖服务的自身问题出现调用故障或延迟，而这些问题会导致调用方的服务对服务出现延迟，若此时调用的请求不断增加，最后就会出现等待故障的依赖响应而形成任务挤压，最终导致服务的瘫痪。
        在微服务脚骨中，存在着这么多的服务单元，若一个单元出现故障，就会因依赖关系形成古战蔓延，最终瘫痪真个系统，为了解决此问题，就出现断路器模式。
断路器本身就是一个开关装置，用于保护线路过载，当线程中有电器发生短路时，就会及时切断。
        在分布式架构中，断路器模式的作用也是类似，当某个单元发生古战之后，通过断路器的故障监控，想调用方返回一个错误响应，而不是长时间等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延
        Netflix Hystrix:在Spring-Cloud中使用Hystrix来实现断路器的功能。框架的目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更加强大的容错能力。
        Hystrix具备有回退机制和断路器功能的线程和信号隔离，请求花村和请求打包，以及监控和配置等功能

### 二、分布式配置中心
        Spring Cloud Config:为服务端和客户端提供了分布式系统的外部化配置支持。配置服务器为各应用的所有环境提供了一个中心化的外部配置。
        他实现了对外部服务端和客户端对Spring Environment 和 PropertySource抽象的映射，所以他处理使用于Spring构建的程序，也可以在任何其他的语言运行的应用程序中使用。
        作为一个应用可以通过部署管道来进行测试或者投入生产，我们分别为这些环境创建配置来运行。
        配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。当然他也提供本地化文件系统的存储方式，俩个方面介绍如何使用分布式配置来存储微服务应用多环境的配置内容

### 三、服务网关
        Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及负载均衡,通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。
        为了使得服务集群更加健壮，使用Hystrix的熔断机制来避免在微服务中一个服务影响其他的服务。
        架构不足之处：
            1.首先，破坏了服务无状态的特点。为了保证对外的服务的安全性，我们需要对服务访问做权限控制，然而开放服务的权限会污染整个开发服务的业务逻辑，这样带来的问题就是直接破坏了服务集群中REST API无状态的特点。从具体的开发和测试的角度来说，在工作中除了需要考虑实际的业务逻辑之外，还血药对接口访问的控制处理
            2.其次，无法直接服用即有接口，当我们需要对一个既有的集群内访问接口，实现外部服务访问时，我们不得不在原有的接口上做接口增加逻辑校验，或增加一个代理现权限控制，无法直接服用原有的接口。
        为了解决这些问题，我们需要将权限控制这样类似的东西从我们的服务单元中抽离出来，然而最适合的这些逻辑的地方就是处于对外王文最前端的地方，因此我们需要一个更加强大的负载均衡器，于是引入【服务网关】技术。
        服务网关是微服务架构中不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、负载均衡功能外，还具备权限控制等功能，Spring Cloud Netflix的【Zuul】就担任了这样的角色，为微服务架构提供了前门保护的作用，同时将权限控制这些重的非业务内容迁移到服务路由层面，使得服务集群主题能够具备更高的可复用性和可测试性。
    服务路由：
        通过服务路由功能，我们在对外提供服务的时候，只需要通过暴露Zuul中配置的调用地址就可以让调用方让调用方统一来访问我们的服务，而不需要料及诶具体提供服务的主机信息。
        Zuul中提供了俩中映射方式：
            
            1.通过URL直接映射，配置DEMO：
              zuul.routes.api-a-url.path=/api-a-url
              zuul.routes.api-a-url.url = http://localhost:2222/
        该配置，定义了所有到Zuul中的规则为:/api-a-url的都是访问映射到http://localhost:2222/上，即：访问http://localhost:5555/api-a-url/add?a=2&b=2的时候，Zuul会将该请求路由到http://localhost:2222/add?a=2&b=2上。
        其中,配置属性zuul.routes.api-a-url.path中的api-a-url部分为路由的名字,可以任意定义,但是一组映射关系的path和url要相同.
            
            2.通过URL映射的方式对于Zuul来说，不是很友好，Zuul需要知道我们所有为服务的地址，才能完成所有的映射配置。而实际上，我们在实现微服务架构时，服务名与服务市里的值的关系在eureka server中已经存在了，所以只需要将Zuul注册到eureka server上去发现其他服务，我们可以实现对serviceId的映射。
              zuul.routes.api-a.path=/api-a/
              zuul.routes.api-a.serviceId = service-A
              zuul.routes.apu-b.path=/api-b
              zuul.routes.api-b.serviceId = service-B
              ereka.client.serviceUrl.defaultZone = http://localhost:1111/eureka/
    
    服务过滤：
        在完成服务路由之后，我们对外开放服务还需要一些安全措施来保护客户端只能访问他应该访问到的资源。搜易我们需要利用Zuul的过滤器来实现我们对外服务的安全控制。
        在服务网关中定义过滤器只需要继承zuulFilter抽象类实现其定义的四个抽象函数就对请求进行拦截与过滤。
        定义一个Zuul过滤器，实现了在请求被路由之前检查请求中是否有accessToken参数，如有就可以路由，没有就直接拒绝访问。重写四个方法：
            1、filterType:返回一个字符串代表过滤器的类型，在zuul中定义了四种不同的生命周期过滤器类型，具体如下：
              .pre :可以在请求被路由之前调用
              .routing:在路由器请求时候被调用
              .post : 在routing和error过滤器之后被调用
              .error : 处理请求时发生错误时被调用
            2、filterOrder：通过int值来定义过滤器的执行顺序
            3、shouldFilter：返回一个boolean类型来判断该过滤器是否要执行，所以通过此函数可实现过滤器的开关。
            4、run：过滤器的具体逻辑。需要注意ctx.setSendZuulResponse(false)让zuul过滤该请求，不对其进行路由。
            
    为啥服务网关是微服务架构的重要部分，是我们必须要去做的原因：
        1.不仅仅实现了路由功能来屏蔽诸多服务细节，更实现了服务级别、负载均衡的路由
        2.实现了接口权限与微服务业务逻辑的解耦。通过服务网关中的过滤器，在各个生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，保证了微服务的无状态，同时降低了微服务的测试难度，让服务本生更集中关注业务逻辑的处理
        3.实现了断路器，不会因为具体微服务的故障而导致服务网关的阻塞，依然可以对外服务













