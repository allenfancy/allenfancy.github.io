---
layout: post
title: "JVM类加载机制"
date: 2016-01-03
description: "JVM类加载机制"
tag: JVM 
---   


### 1. JVM类加载机制
    1. 启动类(Bootstrap)加载器:
        引导类加载器是用 本地代码实现的类加载器，它负责将 <JAVA_HOME>/lib下面的核心类库 或 -Xbootclasspath选项指定的jar包等 虚拟机识别的类库 加载到内存中
    2. 扩展类(Extension)加载器:
        扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的，它负责将 <JAVA_HOME >/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库 加载到内存中
    3. 系统类(System)加载器:
        系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的
        
### 2.类加载双亲委派机制介绍和分析
        通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归 (本质上就是loadClass函数的递归调用)

### 3.源码解析
```
 protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 1.检查是否已经被加载
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        // 2.交给父类加载
                        c = parent.loadClass(name, false);
                    } else {
                        // 3.递归终止条件 最后native查找
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                }

                if (c == null) {
                    // 4.如果父类加载器不能完成加载请求时，再调用自身的findClass方法进行类加载，若加载成功，findClass方法返回的是defineClass方法的返回值
                    long t1 = System.nanoTime();
                    c = findClass(name);
sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```







### eclipse 启动内存优化
    Eclipse开发的时候，有时候会出现oom(out of memory)问题:-Xms256M -Xmx256M -XX:PermSize=256M -XX:MaxPermSize=256M
    /***
     * 关于对Eclipse启动时;的调优处理：eclipse.ini文件
     * 原版：
     * -vm
     * D:/_devSpace/jdk1.5.0/bin/javaw.exe
     * -startup
     * plugins/org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar
     * --launcher.library
     * plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.0.200.v20090519
     * -product
     * org.eclipse.epp.package.jee.product
     * --launcher.XXMaxPermSize
     * 256M
     * -showsplash
     * org.eclipse.platform
     * -vmargs
     * -dosgi.requiredJavaVersion = 1.5
     * -Xverify：none
     * -Xmx512m
     * -Xms512M
     * -Xmn128M
     * -XX:PermSize = 96M
     * -XX:MaxPermSize = 96M
     *#########################################
     *-Xmx512M
     *-XX:MaxPermSize = 256M
     *#########################################
     *编译时间和类加载时间的优化：
     *
     *JDK1.6 的类加载 要比 JDK1.5的类加载的速度慢一些
     * -XX:PrintGCTimeStamps(打印GC停顿时间)
     * -XX:PrintGCDetails(打印GC详细信息)
     * -verbose:gc(打印GC信息，输出内容已被前一个参数包括)
     * 上面的红色部分标示：新增的参数配置，优化Eclipse
     */
