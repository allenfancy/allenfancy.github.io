---
layout: post
title: "消息队列设计精要"
date: 2016-07-13
description: "消息队列设计精要"
tag: MQ 
---   

## 消息队列设计精要
    消息队列已经成为IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。

### 1.何时需要消息队列
        当你需要使用消息队列时，首先要考虑它的必要性。可以使用mq的场景很多，最常见的几种，是做业务解耦/最终一致性/广播/错峰流控等。反之，如果需要强一致性，关注业务逻辑的处理结果，则RPC就更加适合。
        A.解耦：
            解耦是消息队列要解决的最本质问题。所谓解耦，简单点讲就是一个事务，只关心核心的流程。而需要依赖其它系统但不那么重要的事儿，有通知即可，无需等待结果。换句话说，基于消息的模型，关心的是’通知’，而非处理。
        B.最终一致性
            最终一致性指的是俩个系统的状态保持一致，要么都成功，要么都失败。当然有个时间限制，理论上是越快越好，但实际上各种异常的情况下，可能有一定延迟达到最终一致状态，但最终俩个系统的状态是一样的。交易系统中的可靠性通知。所有的跨VM的一致性问题，从技术的角度将通常的解决方案是：
                1.强一致性，分布式事务，但落地太难且成本太高
                2.最终一致性，主要是用于 记录 和 补偿 的方式。在做所有的不确定的事情之前，先把事情记录下来，然后去做不确定的事情，结果可能是：成功、失败或是不确定。不确定可以等价为失败。成功就可以把记录的东西清理掉，对于失败和不确定，可以依靠定时任务等方式把所有失败的事情重新弄一遍，直到成功为止。
        具体来说：本地事务维护业务变化和通知消息，一起落地(失败则一起回滚),然后RPC到达broker，在broker成功落地后，RPC返回成功，本地消息可以删除。否则本地消息一致靠定时任务轮询不断重发，这样就可以保证了消息可靠落地broker.broker往consumer发送消息的过程类似，一直发送消息，直到consumer发送消息成功确认。Kafka在设计层面上就有丢失消息的可能。哪怕只丢千分之一的消息，业务必须用其他的手段来保证结果正确。
        C.广播
            消息队列的基本功能之一就是进行广播。如果没有消息队列，每当一个新的业务方接入，我们都要联调一次新接口。有了消息队列，我们只需要关心消息是否达到队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作
        D.错峰与流控
            短信网关可以使用消息队列来进行降级
总之，消息队列不是万能的。对于需要强事务保证而且延迟敏感的，RPC是由于消息队列的.

### 2.如何设计一个消息队列：
    1.综述：
        我们现在明确了消息队列的使用场景，下一步就是如何设计实现一个消息队列了:基于消息的关系模型，不一定需要broker(消息队列服务端)。Akka(actor模型)、ZeroMQ等，其实都是基于消息的系统设计范式，但是没有broker.之所以要设计一个消息队列，并且配备broker，无外乎要做俩件事情：
            1.消息的转储，在更合适的时间点投递，或者通过一系列手段辅助消息最终能达到消费机制。
            2.规范一种范式和通用的模式，以满足解耦、最终一致性、错峰等需求.掰开细节，最简单的消费队列可以做成一个消息转发器，把一次RPC做成俩次RPC。发送者把消息投递到服务端(Broker),服务端再将消息转发一手到接收端，就是这么简单。一般来讲，设计消息队列的整体思路是
                2.1:先Build一个整体的数据流，例如：producer发送给broker，broker发送给consumer，consumer回复消费确认，broker删除/备份消息等。
                2.2:利用RPC将数据流串起来，然后考虑RPC的高可用性能，尽量做到无撞他，方便水平扩展。
                2.3:考虑如何承载消息堆积，然后在合适的时机投递消息，而处理堆积消息的最佳方式，就是存储，存储的选型需要综合考虑性能/可靠性和开发维护成本等诸多因素。
                2.4:为了实现广播功能，我们必须要维护消费关系，可以利用ZK/config server等保存消费关系。
    完成了上述四个功能后，消息队列基本就实现了。然后考虑高级特性：可靠投递、事务特性、性能优化等。
    设计消息队列时重点考虑的模块为主线，穿插灌输一些消息队列的特性实现方法，来具体分析设计实现一个消息队列时的方方面面。

### 3.实现队列基本功能：
    (所谓消息队列，无外乎俩次RPC加一次转储，当然需要消费端最终做消费确认的情况是三次RPC。既然是RPC，就必然牵扯一系列话题，负载均衡、服务发现、通信协议、序列化协议等)
        1.RPC通信协议：
            服务端提供俩个RPC服务，一个用来接收消息，一个用来确认消息收到。并且做到不管哪个server接收到消息和确认消息，结果一致即可。当然这中间可能还涉及跨IDC的服务的问题。这里和RPC的原则是一致的，尽量优先选择本机房投递。
        2.高可用
            其实所有的高可用，是依赖于RPC和存储的高可用来做的。先来看RPC的高可用，美团的基于MTThrift的RPC框架，Dubbo等，其本身就具有服务自动发现，负载均衡等功能。而消息队列的高可用，只要保证broker接收消息和确认消息的接口是等幂的，并且consumer的几台机器处理消息是幂等的，这样就把消息队列的可用性，转交给RPC框架来处理了。
            如何保证等幂？
                1.共享存储。broker多机器共享一个DB或者一个分布式文件/KV系统，则处理消息自然是幂等的。
                2.不共享存储的队列，如Kafka使用分区加主备模式，就略微麻烦一些。需要保证每一个分区的高可用性，也就是每个分区至少要有一个主备且需要做数据同步，关于HA的细节，PULL模型消息系统的设计。
        3.服务端承载消息堆积的能力
            消息到达服务端如果不经过任何处理就到接收到接收者了，broker就失去了意义。为了满足我们错峰/流控/最终可达等一系列需求，把消息存储下来，然后选择时机投递就显得是顺理成章的了。
        4.存储子系统的选择：
            数据落地的情况下各种存储子系统的选择。理论上，从速度来看，文件系统 > 分布式KV(持久化) > 分布式文件系统 > 数据库，而可靠性却截然相反。
        5.消息关系解析
            消息队列初步具备了转存储消息的能力。下面一个重要的事情就是解析发送接收关系，进行正确的消息投递了。至于广播关系的维护,一般由于消息队列本身都是集群，所以都维护在公共存储上,如config-server,zookeeper等。维护广播关系所要做的事情基本是一致的：发送关系的维护，发送关系变更时的通知

### 4.队列高级特性设计
    1.可靠性投递(最终一致性)
        简单方案:
        P — > B,生产者在发送消息的时候,一定要确保消息在broker上落地。
        B —>  C,Broker要确保Consumer被消费,或者,broker可以重复消费。业务端等幂
        具体：
            1.producer往broker发送消息之前，需要做一次落地
            2.请求到server后，server确保数据落地后再告诉可短发送成功
            3，支持广播的消息队列需要对每个发送endpoint，持久化一个发送状态，直到所有endpoint状态都OK才能删除消息。
    2.消费确认
        当broker把消息投递给消费者后，消费者可以立即响应我接收到了这个消息。但收到了这个消息只是第一步，我们不能处理这里消息却不一定。或许因为消费能力的问题，系统的负荷已经不能处理这个消息；或者是刚才装填机里面提到了消息不是我们要接受到的消息，主动要求重发。
    3.重复消息和顺序消息
        绝对的顺序消息基本是不能实现的，当然在METAQ/KAFKA等Pull模型的消息队列中，单线程生产/消费。排除消息丢失，也是一种顺序消息的解决方案。
        谈到重复消息，主要是俩个话题：
            1.如何鉴别消息重复，并幂等的处理重复消息
            2.一个消息队列如何尽量减少重复消息的投递
    由于消息不能被永久存储，所以在理论上都存在消息从持久化存储移除的瞬间上游还在投递的可能性。因为种种原因重复消息或者错乱的消息还是来到了，通用的解决方案：
            1.版本号
                参考TCP/IP协议，如果想让乱序的消息最后能够正确的被组织，那么就应该只接受比当前版本号大一的消息。并且在一个session周期内要一直保存各个消息的版本的号。
                如果到来的顺序是21，则先把2存起来，待1到来后，先处理1，再处理2，这样就重复性和顺序性要求就都达到了
            2.状态机
                基于版本号来处理重复和顺序消息听起来不错，但是使用版本号的最大的问题是：
                1.对发送方必须要求消息带业务版本号
                2.下游必须存储消息的版本号，对于要求严格保存顺序的
    4.中间件对于重复消息的处理
        回归到消息队列的话题。上述通用的版本号/状态机/ID判重解决方案里，哪些是消息队列该做的，哪些是消息队列不该做业务方处理的呢？减少重复消息的关键步骤：
            1.broker记录MessageId，直接投递成功后消除，重复的ID到来不做处理，这要只要发送者在清除周期内能感知到消息投递成功，就基本不会在server端产生重复消息。
            2.对于server投递到consumer的消息，由于不能确定对端是在处理过程中还是消息发送丢失情况下，有必要记录下投递的IP地址。觉得重发之前询句这个IP，消息处理成功了吗？如果询问无果，再重发。
    5.事务
        持久性是事务的一个特性，然而只满足持久性却不一定能满足事务的特性。解决方案从大方向有俩种：
        1.俩阶段提交，分布式事务
        2.本地事务，本地落地，补偿发送
    分布式事务存在的最大问题是成本太高，俩阶段提交协议，对于仲裁down机或者单点故障，几乎是一个无解的黑洞。对于交易密集或IO密集型的 应用，没有办法承载那么高的网络延迟，系统复杂性。
    并且成熟的分布式事务一定构建于比较靠谱的DB和商用中间件上，成本太高。那如何使用本地事务解决分布式事务的问题呢？以本地和业务在一个数据库实例中建表为例，与扣钱的业务操作在同一个事务里，将消息插入本地数据库。
    如果入库失败，则业务回滚；如果消息入库成功，事务提交。然后发送消息(可以实时发送，不需要定时任务，以提高消息实时性)。
    而消息只要成功落地，很大程度上就没有丢失的风险。而消息只要投递到服务端确认后本地才做删除，就玩了producer->broker的可靠投递，而且当消息存储异常时，业务也是可以回滚的。
    本地事务存在俩个最大的私用障碍：
        1.配置较为复杂，绑架业务方，必须本地数据库实例提供一个库表
        2.对于消息延迟高敏感的业务不使用
    6.性能相关
        异步/同步：
            异步、同步和oneway是三件事儿。
            异步：归根揭底你还是需要关心结果的，但可能不是当时的时间点关心，可以用轮询或回调等方式处理结果；
            同步：是需要当时关心的结果的
            oneWay：是发出去就不管死活的方式，这种对于某些完全对可靠性没有要求的场景还是使用
        任何的RPC都是存在客户端异步与服务端异步的，而且是可以任意组合的，客户端同步对服务端异步，客户端同步对服务端同步，客户端异步对服务端同步。
        对于客户端来说，同步与异步主要是拿到一个Result，还是Future(Listenable)的区别。实现方式可以是线程池，NIO或其他事件机制。