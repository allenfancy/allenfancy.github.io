---
layout: post
title: "设计模式-中介模式"
date: 2015-02-16
description: "设计模式-中介模式"
tag: 设计模式
---   



### 1.开放-封闭原则
    
    1.概念
        一个软件实体类、模块和函数应该对扩展开发，对修改关闭。模块应该尽量在不修改原代码的情况进行扩展.
        在软件周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给代码引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。
        当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有代码来实现变化。
        开放封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。
        开发人员应该仅对程序中呈现的频繁变化的那些部分作出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。
    
    2.注意事项：
        1.通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法。
        2.参数类型、引用对象尽量使用接口或者抽象类，而不是实现类
        3.抽象层尽量保持稳定，一旦确定不允许修改。
　　    
### 2.单一职责原则
        概念:就一个类而言，应该仅有一个引起它变化的原因。
        当我们在做编程的时候，很自然的回个一个类加上各种各样的功能。这样意味着，无论任何需求要来，你都需要更改这个类，这样其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活性。
        如果一个类承担的职责过多，就等于把这些职责耦合起来，一个职责变化可能会削弱或者抑制这个类完成其他职责的能力。
        这种耦合会导致脆弱的设计，当变化发生时，设计会遭到很多意想不到的破坏。
　　
### 3.依赖倒转原则
        概念：依赖倒转原则是程序要依赖于抽象接口，不要依赖于具体实现。简单的来说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块的耦合。
        
        有时候为了代码复用，一般会把常用的代码写成函数或类库。这样开发新项目的时候直接用就行了。
        比如做项目的时候大多要访问数据库，所以我们把访问数据库的代码写成了函数。每次做项目去调用这些函数。那么问题来了，我们要做新项目的时候，发现业务逻辑高层模块都是一样的，但客户却希望使用不同的数据库或存储方式，这时就出现了麻烦。我们希望能再次利用这些高层模块，但是高层模块都是与低层的访问数据库绑定在一起，没办法复用这些高层的模块。
        所以不管是高层模块和底层模块都应该依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个更改都不用担心。
    注意事项：
        1.高层模块不应该依赖于低层模块。两个都应该依赖抽象。
        2.抽象不应该依赖结节。细节应依赖于抽象。

### 4.迪米特法则（也称为最小知识原则）
        概念：一个软件实体应当尽可能的少与其他实体发生相互作用。
        每一个软件单位对其他软件单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
        迪米特法则的初衷在于降低类之间的耦合。
        由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。
        迪米特法则不希望类之间建立直接的联系。如果有真的需要建立联系的，也希望能通过他的友元类来转达。
        因此，应用迪米特法则有可能造成一个后果就是:系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互关系，这在一定程度上增加了系统的复杂度。

### 5.接口隔离原则
    概念：客户端不应该依赖他不需要的接口，类间的依赖关系应建立在最小的接口上。
    接口隔离原则的核心定义，不出现臃肿的接口，但是“小”是有限度的，首先就是不能违反单一职责原则。

### 6.里氏代换原则
    概念：里氏代换原则是面向对象设计的基本原则之一。即任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能被真正复用，而衍生类也能够在积累的基础上增加新的行为，里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。在基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

    当满足继承的时候，父类肯定存在非私有的成员，子类肯定是得到了父类的这些非私有成员（假设，父类的成员全部是私有的，那么子类没办法从父类继承任何成员，也就不存在继承的额概念了）。既然子类继承了父类的这些非私有成员，那么父类对象也就可以在子类对象中调用这些非私有成员。所以，子类对象可以替换父类对象的位置。

    在里氏带环原则下，当需求有变化时，只需继承，而别的东西不会改变。由于里氏代换原则才使得开放封闭称为可能。这样使得子类在父类无需修改就可以扩展。　　