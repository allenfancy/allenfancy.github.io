---
layout: post
title: "mysql索引"
date: 2018-05-10
description: "索引"
tag: MySQL
---

## 索引类型
    主键索引的叶子节点存的是整行数据。在innoDB里，主键索引页成为聚集索引(cluster index)
    非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引称为二级索引(secondary index)

## 回表
    使用普通索引查询方式，则需要先搜索普通索引树，得到ID的值，再到主键索引树搜索一次。这个过程称为回表.
    看下面示例如何进行查询
    表结构:
    create table T(
 	    id int primary key,
	    k int NOT NULL DEFAULT 0,
	    name varchar(16) NOT NULL DEFAULT '',
	    index k(k))
    engine=InnoDB;
    SQL:
        1.select * from T where k between 3 and 5
        2.select id from T where k between 3 and 5
    执行过程：
        1. 在k索引树上找到k=3的记录，取得ID=300
        2. 在到id索引树上找到ID=300对应的记录
        3. 在k索引树取下一个值k=5，取得ID=500
        4. 再回到id索引树上找到ID=500对应的记录
        5. 在k索引树取下一个值k=6，不满足条件，循环结束
    根据上述分析，可以看出，SQL2的执行效率会比SQL1高，减少回表，故此这也是SQL优化的手段

## 覆盖索引
    上述的SQL2中，索引k已经覆盖了查询需求，故此称为覆盖索引。
    由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段.
    但这不意味着将所有字段都建立索引，因为索引维护也是需要花费很大的代价

## 前缀索引~最左前缀原则
    在建立联合索引的时候，如何安排索引内的字段顺序.
    如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的.

## 索引下推
    在MySQL5.6引入的索引下推优化(index condition pushdown),可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。


## 杂谈
### 3.3.1 索引
    索引是存储引擎用于快速查找到记录的一种数据结果，索引类似一本书的目录，可以根据目录快查找的数据。

### 3.3.2 索引的类型
    索引是在MySQL的存储引擎层中实现的，而不是在服务层实现的。所以每种存储引擎的索引都是不一样的，也不是所有的存储引擎都支持所有的索引类型

#### 3.3.2.1 B+Tree 索引
    B+Tree索引是MyISAM和InnoDB的默认的索引类型，也可以在创建索引的时通过USING BTREE来显示执行。B-Tree是一种多叉平衡树、
    场景：
        1. 等值匹配
            = != <> IN  (NOT IN) <=> 查询语句的优化
        2. 范围匹配 
            > >= < <= BTEWEEN AND 等范围查询语句的优化
        3. 匹配最左前缀
            name like bai%这种模糊匹配的查询，是可以利用name字段上建立的索引，来欧化查询的
        4. 覆盖索引
            B-Tree索引的key存放的子弹的值，如果KEY中包含所有需要查询字段的值，就称为覆盖索引，覆盖索引能提高性能
        5. 排序
            B-Tree 索引是排好序的，所以MySQL可以用来优化ORDER BY 和 GROUP BY等操作

#### 3.3.2.2 Hash索引
    效率高，但是限制多。如：
        1. 只有精确匹配索引列的查询才有效，因为hash索引是利用索引的所有列的字段值来计算hash值的
        2. 只支持等值比较查询，不能支持范围查询
        3. 哈希索引的只包含索引字段的哈希值和指向数据的指针，所以不能使用索引中的值来避免读行
        4. hash索引的数据是无序的，无法用于排序

#### 3.3.2.2 全文索引
    全文索引是一种通过建立倒排索引，快速匹配文档的方式

### 3.3.3 聚簇索引和非聚簇索引

#### 3.3.3.1 聚簇索引(innodb的索引类型实际上就是聚簇索引)
    聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，Innodb的索引实际上是将主键(primary eky)与数据行存放在同一个文件的，一张表只能有一个聚簇索引.
    InnoDB要求表必须有主键（MyISAM可以没有）,如果没有显式指定,则MySQL系统会用一个唯一且不为空的索引列做为主键,如果不存在这种列,则MySQL自动为InnoDB表生成一个隐含字段作为主键。
    InnoDB的普通索引(二级索引)的叶子节点中存放的是PRIMARY KEY的值，所以需要先查询普通索引的叶子界定啊找到对应的主键值，然后再根据主键值去聚簇索引中查找对应的数据.
        1. InnoDB将主键与数据聚集在一起的方式，让主键顺序的插入和查询效率非常的高，但是更新主键的字段或者不按照主键的顺序插入数据的代码会比较高，所以主键的选取非常重要(使用AUTO INCREMENT字段或者
        应用程序生成的顺序递增字段要比无序的UUID好）
        2. 二级索引会保存主键的值，所以主键的值不要太大

#### 3.3.3.3 非聚簇索引(MyISAM引擎使用的是非聚簇索引)
    MyISAM引擎的一张表中，会有三种文件：FRM(表结构)、MYD(数据，即数据库中的每个行)、MYI(索引)
    MYSQL使用索引查询数据时，先到MYI文件中找到数据存储的位置指针，然后再到MYD文件中读取数据

### 3.3.4 高效的索引
    索引的代价：消耗存储空间，同时索引会加重插入、删除和修改记录的负担(每次这种操作都会让B+Tree中的数据结构发生变化，比如，分裂，旋转等)
    1. 独立的列
        索引不能用于计算，，如：select * from table where id + 1 = 5; //不会使用索引
    2. 索引的选择性
        索引的选择性是指不重复的索引值(Cardinality)和数据表的记录总数的比值(0,1],索引的选择性越高(接近1),查询时能够过滤掉的更多的行，效率也更高.
        越散列的值也高，过滤的数量越多
    3. 前缀索引
        对于字符列，可以使用列的前缀代替整个列作为索引key，当前缀长度适合时，可以做到即使前缀索引的选择接近全列索引，同时大大节约索引空间。
        对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引.
    4. 联合索引
        MySQL 允许对表上的多个列进行索引，联合索引的创建方法与单个索引创建的方法不一样，不同之处仅在于有多个索引列.